# Introduction:
- For writing any java program whether it is simple or complex the most commonly required classes and interfaces are grouped into a separate package which is nothing but java.lang package.
- we are not required to import java.lang package explicitly because all classes and interfaces present in lang package by default available to every java program

# java.lang.Object:
- The most commonly required methods for every java class (whether it is predefined class or customized class) or defined in a separate class which is nothing but Object class.
- Every class in java is the child class of object either directly or indirectly so that Object class methods by default available to every java class.
- Hence, Object class is considered as root of every java class.
- If our class doesn't extend any other class then only our class is the direct child class of Object.
- If our class extends any other class then our class is indirect child class Object.
- Either directly or indirectly java won't provide support for multiple inheritance w.r.t classes
- Object class defines the following 11 methods:
1. public String toString()
2. public native int hashCode()
3. public boolean equals(Object o)
4. protected native Object clone() throws CloneNotSupportedException
5. protected void finalize() throws Throwable
6. public final class getClass()
7. public final void wait() throws InterruptedException
8. public final native void wait(long ms) throws InterruptedException
9. public final void wait(long ms, int ns) throws InterruptedException
10. public native final void notify()
11. public native final void notifyAll()

# toString():
- We can use toString() method to get string representation of an Object
- String s = obj.toStrin();
- whenever we are trying to print Object reference, internally toString() method will be called.
- Student s = new Student();
- System.out.println(s);  => System.out.println(s.toString());
  - If our class doesn't contain toString() method then object class toString() method will be executed.
  e.g.
    class Student {
    String name;
    int rollno;
    Student(String name, int rollno) {
    this.name = name;
    this.rollno = rollno;
    }
    public static void main(String[] args) {
    Student s1 = new Student("Sam", 1);
    Student s2 = new Student("John", 2);
    System.out.println(s1);
    System.out.println(s1.toString());
    System.out.println(s2);
    }
    }
  o/p: 
    Student@2f92e0f4
    Student@2f92e0f4
    Student@28a418fc

- In the above example object class toString() method got executed which is implemented as follows:
public String toString() {
  return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
// classname@hashcode-in-hexadecimal-form

- based on our requirement we can override toString() method to provide our own string representation.
- whenever we are trying to print Student object reference to print name and rollno we have to override toString() method as follows:
  public String toString() {
  return name + " " + rollno;
  }
- In all wrapper classes, in all collection classes, String class, StringBuffer and StringBuilder classes toString() method is overridden for meaningful string representation hence it is highly recommended to override toString() method in our class also.
  import java.util.ArrayList;

class StringDemo {
public String toString()
{
return "StringDemo";
}
public static void main(String[] args) {
String s = new String("Ayesha");
System.out.println(s);
ArrayList list = new ArrayList();
list.add("A");
list.add("B");
System.out.println(list);
StringDemo s1 = new StringDemo();
System.out.println(s1);
}
}

# hashcode():
- For every object a unique number is generated by JVM which is nothing but hashCode.
- hashCode() won't represent address of object
- JVM will use hasCode while saving objects into hashing related data structures like hashtable, Hash map, Hash set etc.
- The main advantage of saving objects based on hashCode is search operation will become easy
- The most powerful algorithm upto today is hashing.
- If you are giving the chance to object class hashCode() method, it will generate hashCode based on address of the object
- It doesn't mean hashCode represent address of the object
- Based on our requirement we can override hashCode() method in our class to generate our own hashCode.
  - Overriding hasCode() method is said to be proper if and only if for every object we have to generate a unique number as hashCode.
    class Student {
    public int hashCode()
    {
       return 100;
    }
    }
- Improper way
- This is an improper way of overriding hashCode() method because for all Student Object we are generating same number as hashCode 

class Student {
  public int hashCode()
  {
  return rollno;
  }
}
- Proper
  - This is a proper way of overriding hashCode() method because for all Student Object we are generating unique number as hashCode

# toString() vs hashCode():
- If we are giving a chance to object class toString() method it will internally call hashCode() method
- If we are overriding toString() method then our toString() method may not call hashCode() method

# equals():
- we can use equals() method to check equality of two objects.
- obj1.equals(obj2)
- If our class does not contain equals() method the object class equals() method will be executed
e.g.

class Student {
String name;
int rollno;
Student(String name, int rollno) {
this.name = name;
this.rollno = rollno;
}
public static void main(String[] args) {
Student s1 = new Student("Sam", 1);
Student s2 = new Student("Smith", 2);
Student s3 = new Student("Steve", 3);
Student s4 = s1;
System.out.println(s1.equals(s2));  // false
System.out.println(s1.equals(s3));  // false
System.out.println(s1.equals(s4));  // true
}
}

- In the above example object class equals method got executed which is meant for reference comparison (address comparison) i.e. if the two reference pointing towards same object then only it returns true.
- Based on our requirement we can override equals() method for content comparison.
- While overriding equals() method for content comparison we have to take care about the following:
1. What is the meaning of equality (whether we have to check only names or only roll numbers or  both)
2. If we are passing different type of object our equals() method should not rise ClassCastException i.e. we have to handle ClassCastException to return false
3. If we are passing null argument then our equals() method should not rise NullPointerException i.e. we have to handle NullPointerException to return false.

- The following is the proper way of overriding equals() method for content comparison in a proper way:
e.g.

class Student {
String name;
int rollno;
Student(String name, int rollno) {
this.name = name;
this.rollno = rollno;
}
public boolean equals(Object obj) {
try {
String name1 = this.name;
int rollno1 = this.rollno;
Student s = (Student)obj;  // ClassCastException
String name2 = s.name;
int rollno2 = s.rollno;
if (name1.equals(name2) && rollno1 == rollno2) {
return true;
} else  {
return false;
}
} catch (ClassCastException e) {
return false;
} catch (NullPointerException e) {
return false;
}
}
public static void main(String[] args) {
Student s1 = new Student("Sam", 1);
Student s2 = new Student("Sam", 1);
Student s3 = new Student("Steve", 3);
Student s4 = s1;
System.out.println(s1.equals(s2));
System.out.println(s1.equals(s3));
System.out.println(s1.equals(s4));
}
}


# Note : In String class .equals() method is overridden for content comparison hence even though objects are different if content is same then .equals() method returns true
# Note : In StringBuffer class .equals() method is not overridden for content comparison hence if objects are different then .equals() method returns false even though content is same
e.g.
class Test {
public static void main(String[] args) {
String s1 = new String("Hello");
String s2 = new String("Hello");
StringBuffer sb1 = new StringBuffer("Hello");
StringBuffer sb2 = new StringBuffer("Hello");
System.out.println(s1 == s2);   // false
System.out.println(s1.equals(s2));  // true
System.out.println(sb1 == sb2);  // false
System.out.println(sb1.equals(sb2)); // false
}
}

# getClass():
- We can use getClass() method to get runtime class definition of an object
- public final Class getClass()
- By using Class class Object we can access class level properties like fully qualified name of the class, methods information, constructor information etc.
- e.g.
  import java.lang.reflect.Method;

class Test {
public static void main(String[] args) {
int count = 0;
Object o = new String("Hello");
Class c = o.getClass();
System.out.println(c.getName());
Method[] m = c.getDeclaredMethods();
for (Method m1 : m) {
count++;
System.out.println(m1.getName());
}
System.out.println(count);
}
}

e.g. To display database vendor specific connection interface implemented Class name:
Connection con = Drivermanager.getConnection();
System.out.println(con.getClass().getName());

# Note: After loading every .class file jvm will create an object of the type java.lang.Class in the heap are. Programmer can use this class object to get class level information. we can use getClass() method very frequently in reflections.

# finalize():
- just before destroying an object garbage collector calls finalize() method to perform cleanup activities.
- Once finalize() methods completes automatically garbage collector destroys that object.

